# 인터페이스 (Interface)

클래스에서 특정 기능을 구현하도록 강제하는 추상 자료형이다.

 인터페이스는 **추상메소드와 상수**로만 이루어져 있지만,  **자바 8** 이후부터는 디폴드 메소드와 정적 메소드를 구현할 수 있다.


<br>

 
### 인터페이스 정의하는 방법

``` java
접근제어자 interface 인터페이스명 {
	public static final 타입 상수명 = 값; // 상수
	...
	public abstract 메소드명(매개변수..); // 추상 메소드
	...
	default 타입 메소드명(매개변수..){...} // 디폴트 메소드 (자바8 이후)
	...
	static 타입 메소드명(매개변수..){...} // 정적 메소드 (자바8 이후)
}
```

인터페이스를 선언할 때는 접근 제어자(`public` / `default`)와 함께 `interface` 키워드를 사용한다.

1. **상수** (절대적)
   - 인터페이스의 모든 필드는 `public static final` 이어야한다.
2. **추상 메소드** (강제적)
   - 모든 메소드는 `public abstract` 이어야한다. 
3. **디폴트 메소드** (선택적)
   - 인터페이스에서 기본적으로 제공하며, 오버라이딩할 수 있다.
4. **정적 메소드** (절대적)
   - 인터페이스에서 제공하는 것으로 무조건 사용해야 한다.

> 💡**참고** <br>
> 인터페이스 모든 필드의 `public static final` 와 메소드의 `public abstract` 는 모든 인터페이스에 공통으로 적용되는 부분이므로 제어자는 생략할 수 있다. 생략된 제어자는 컴파일 시 자바 컴파일러가 자동으로 추가한다.


<br>

 
**🍅 인터페이스 장점**
- 변경에 유리한 유연한 설계가 가능하다.
- 표준화가 가능하다. (예. JDBC)
- 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축할 수 있다.
- 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립적인 프로그래밍이 가능하다.

<br>
 
### 인터페이스 구현하는 방법

인터페이스는 추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수 없다.

따라서 인터페이스가 포함하고 있는 추상 메소드를 구현해 줄 클래스를 작성해야만 한다.


<br>

 
🍅 **구현 클래스**

``` java
class 클래스명 implements 인터페이스명 {...}
```

만약 모든 추상 메소드를 구현하지 않는다면, `abstract` 키워드를 사용해 추상 클래스로 선언해야한다.

인터페이스는 다중 구현이 가능하다. 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 구현해야 한다.


<br>

 
🍅 **익명 구현 객체**

구현 클래스를 만드는 것이 일반적이지만, 일회성의 객체를 위해서는 비효율적이므로 해당 방법을 사용한다.

``` java
인터페이스명 변수명 = new 인터페이스명 (){...}
```


<br>

 
> 💡**참고** <br>
> 자바에서는 상속과 구현을 동시에 할 수 있다. <br>
> 
> ``` java
> class 클래스명 extends 상위클래스명 implements 인터페이스명 {...}
> ```


<br>
 
### 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

인터페이스를 구현한 클래스들은 인터페이스 참조 변수로 구현 클래스를 참조할 수 있다.

인터페이스의 다형성을 활용해 레퍼런스 타입으로 구현체의 사용을 제한시킬 수 있다.

참조된 구현 클래스들은 자동으로 업 캐스팅된다.

``` java
interface Calculable{
    double PI = 3.14;
    int sum(int v1, int v2);
}

interface Printable{
    void print();
}

class RealCal implements Calculable, Printable{
    public int sum(int v1, int v2) {
        return v1+v2;
    }
    public void print() {
        System.out.println("This is RealCal!!");
    }
}

class AdvancedPrint implements Printable{
    public void print() {
        System.out.println("This is RealCal!!");
    }
}
```

``` java
public class InterfaceApp {
    public static void main(String[] args) {
        Printable c = new RealCal();
        c.print();
    }
}
```

- 인터페이스 타입으로 선언한 객체는 구현 클래스 내에서 생성한 메서드, 필드를 사용할 수 없다.
  - `InterfaceApp`에서 `Printable`의 레퍼런스 타입으로 클래스를 생성시에 해당 변수의 레퍼런스 타입을 `Printable` 인터페이스로 지정을 하면 `print()`만 사용가능하고 `sum()`기능은 사용을 제한시킬 수 있다.
- 구현 클래스에서 `@Override` 하지 않은 메서드는 **명시적으로 다운 캐스팅**을 해줘야 사용할 수 있다.


<br>
 
### 인터페이스 상속

인터페이스는 클래스와 다르게 다중 상속이 가능하다.

인터페이스 상속도 클래스와 마찬가지로 `extends` 키워드를 사용한다.

- ⚠️ 다중 상속 불가능한 경우
  - 부모 인터페이스에 있는 메소드 중 **메소드명과 파라미터 형식은 같지만, 반환 타입이 다른** 메소드가 있다면 어떤 것을 상속받느냐에 따라 규칙이 달라지기 때문에 다중 상속이 불가능하다.
- `Object`가 최고 조상이 아니다.
  - 인터페이스의 조상은 인터페이스만 가능하다. 


<br>
 
### 인터페이스의 기본 메소드 (Default Method), 자바 8

인터페이스는 자바 8 이전에는 추상 메소드만 선언할 수 있었다.

자바 8부터 인터페이스에 default 메소드와 static 메소드를 추가하는 것이 가능해졌다.

> 🤔 **왜 만들어졌을까? “하위 호환성”**<br>
> 자바 8 이전의 인터페이스는 인터페이스에 변경사항이 발생할 경우, 해당 인터페이스를 구현하고 있는 모든 구현체를 수정해야 한다는 단점이 있었다.<br>
> **디폴트 메소드는** 추상 메소드가 아니기 때문에 **메소드에 변경사항이 발생하더라도 구현체를 변경할 필요가 없다.** 

<br>

``` java
default 타입 메소드명(매개변수..){...}
```

메소드 선언 시 `default` 키워드를 명시하면 된다. 

디폴트 메소드는 구현 클래스에서 강제적으로 구현할 필요가 없고, 필요한 경우 선택적으로 오버라이딩할 수 있다.

> ⚠️ **같은 default 메소드가 정의되어있는 두 인터페이스를 구현해야 하는 경우**<br>
> 구현 클래스가 해당 메소드를 재정의해야한다. 그렇지 않으면 컴파일 에러가 발생한다.

<br>

> 💡 **참고: 디폴트 메소드가 구현체의 메소드와 이름이 중복될 경우** <br>
> 이 경우에는 디폴트 메소드가 무시되고, **구현체의 메소드가 우선권을 갖는다.**  <br>
> 상속 관계에서도 부모 클래스의 메소드가 상속되고, 인터페이스의 디폴트 메소드는 무시된다.

<br>
 
### 인터페이스의 static 메소드, 자바 8

``` java
static 타입 메소드명(매개변수..){...}
```

메소드 선언 시 `static` 키워드를 명시하면 된다. 접근제어자는 항상 `public`으로 간주한다.

`static` 메소드이기 때문에 구현 클래스에서 오버라이딩할 수 없다.

구현체의 인스턴스를 생성하지 않고도 인터페이스만으로 바로 메소드를 호출할 수 있다.

``` java
interface A {
   void method1();
   static void method2() {
      System.out.println("static method");
   }
}

public class Test {
   public static void main(String[] args){
      A.method2();
   }
}
```

<br>
 
### 인터페이스의 private 메소드, 자바 9

인터페이스의 메소드는 `public`이었는데, 자바 9부터는 `private`을 사용함으로써 외부에 공개하지 않을 수 있게 되었다.

이로인해 코드의 중복을 피하고 인터페이스에 대한 캡슐화를 유지할 수 있게 한다.

**🍅 인터페이스의 private 메소드 특징**
- 디폴트 메소드처럼 구현체를 가져야한다.
- 인터페이스 내부에서만 사용되는 메소드이다.
  - 구현클래스에서 재정의 할 수도 없고, 자식 인터페이스에서 상속할 수도 없다.
- `private` 메소드
  - 인터페이스의 `static` 키워드가 없는 메소드에서만 사용 가능하다.
  - `private`, `abstract`, `default`, `static` 메소드 호출이 가능하다.
- `private static` 메소드
  - 인터페이스의 모든 메소드에서 사용가능하다.
  - `static`, `private static` 메소드만 호출이 가능하다.

<br>

> 참고<br>
> [1] https://youn12.tistory.com/31 <br>
> [2] https://haemanlee.tistory.com/19 <br>
> [3] https://youngjinmo.github.io/2021/02/livestudy-week-08/#reference

