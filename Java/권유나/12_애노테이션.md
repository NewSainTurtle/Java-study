## 자바 애노테이션(Annotation)
자바의 애노테이션은 소스코드에 추가해서 사용할 수 있는 메타 데이터의 일종이다.

> 메타 데이터란, 애플리케이션이 처리해야할 데이터가 아니라 컴파일 과정과 실팽 과정에서 코드를 어떻게 처리해야하는 지를 알려주기 위한 추가 정보이다.

- 보통 `@` 기호를 앞에 붙여서 사용한다.
- JDK 1.5 버전 이상에서 사용 가능하다.
- 클래스 파일에 임베디드되어 컴파일러에 의해 생성괸 후 자바 가상머신에 포함되어 작동한다.

### 📌 애노테이션의 종류
- 표준(내장) 애노테이션
- 메타 애노테이션
- 사용자 정의 애노테이션

## 표준 애노테이션
- `@Override`
- `@Deprecated`
- `@FunctionalInterface`
- `@SuppressWarnings`
- …

### 📌 @Override

오버라이딩을 올바르게 했는지 컴파일러가 체크한다.

``` java
class Parent{
	void parentMethod(){}
}

class Child extends Parent{
	@Override
    void pparentmethod(){} // E: 잘못된 오버라이드, 메소드 스펠링 틀림
}
```

### 📌 @Deprecated

앞으로 사용하지 않을 것을 권장하는 필드나 메소드에 붙인다.

`@Deprecated`가 붙어있는 메소드를 사용하면 메소드명에 취소선이 그어져있다.

> 🤔 **왜 없애지 않고 애노테이션을 붙이는 걸까?** <br>
> 자바는 하위호환성을 중요시 여긴다.<br>
> 이전에 해당 메소드로 개발을 진행한 프로젝트들이 있기 때문에 유지는 하되, 권장하지 않는다.

### 📌 @FunctionalInterface

함수형 인터페이스에 붙이면, 컴파일러가 올바르게 작성했는지 체크한다.

해당 애노테이션은, “하나의 추상메서드만 가져야 한다”는 함수형 인터페이스의 제약을 확인한다.

또한, 함수형 인터페이스라는 것을 알려주는 역할도 한다.


### 📌 @SuppressWarnings

컴파일러의 경고 메세지가 나타나지 않게 한다.

``` java
@SuppressWarnings("unchecked")
ArrayList list = new ArrayList(); // 제네릭 타입을 지정하지 않음
list.add(obj); // 경고 발생: unchecked
```

`ArrayList`를 선언할 때 제네릭을 통해 타입에 대한 정보를 기입하지 않았다. 그래서 타입을 선언하지 않았자는 “unchecked” 경고 메세지가 뜨게 된다.

하지만 `@SuppressWarnings("unchecked”)`를 입력했지 때문에 “unchecked”에 대한 경고는 출력되지 않는다.

| 애노테이션                            | 설명                                    |
|----------------------------------|---------------------------------------|
| @SuppressWarnings(“all”)         | 모든 경고를 억제                             |
| @SuppressWarnings(“cast”)        | 타입 캐스트 관련 경고 억제                       |
| @SuppressWarnings(“dep-ann”)     | 사용하지 말아야할 주석 관련 경고 억제                 |
| @SuppressWarnings(“deprecation”) | Deprecated 메소드를 사용한 경우 발생하는 경고 억제     |
| @SuppressWarnings(“fallthrough”) | switch문에서 break 구문 누락 관련 경고 억제        |
| @SuppressWarnings(“finally”)     | finally 블럭 관련 경고 억제                   |
| @SuppressWarnings(“null”)        | null 관련 경고 억제                         |
| @SuppressWarnings(“rawtypes”)    | 제네릭을 사용하는 클래스 매개 변수가 특정되지 않았을 때 경고 억제 |
| @SuppressWarnings(“unchecked”)   | 검증되지 않은 연산자 관련 경고 억제                  |
| @SuppressWarnings(“unused”)      | 사용하지 않는 코드 관련 경고 억제                   |

두 가지 이상을 함께 사용하는 경우 `@SuppressWarnings({"unused", "unchecked"})`처럼 객체 형식으로 묶어서 사용한다.

**보통 경고가 많은 경우, 확인된 경고는 해당 애노테이션을 붙여서 새로운 경고를 알아보지 못하는 것을 방지하기 위해 사용한다.**

## 메타 애노테이션

애노테이션을 위한 애노테이션이다.

### 📌 @Target

애노테이션을 정의할 때, 적용대상을 지정하는 데 사용한다.

- `ElementType.TYPE`: 클래스, 인터페이스, 열거 타입
- `ElementType.ANNOTATION_TYPE`: 애노테이션 
- `ElementType.FIELD`: 멤버 변수, 열거 타입 상수
- `ElementType.CONSTRUCTOR`: 생성자
- `ElementType.METHOD`: 메소드
- `ElementType.LOCAL_VARIABLE`: 로컬변수
- `ElementType.PACKAGE`: 패키지
- `ElementType.TYPE_PARAMETER`: (JDK1.8) 타입 매개변수(제네릭과 같은 매개변수)
- `ElementType.TYPE_USE`: (JDK1.8) 타입이 사용되는 모든 대상

``` java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.TYPE_USE})
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation{}

@MyAnnotation // 적용 대상이 TYPE(클래스, 인터페이스)인 경우
class MyClass{

	@MyAnnotation //적용 대상이 FIELD인 경우
    int i;
    
    @MyAnnotation //적용 대상이 TYPE_USE인 경우
    MyClass mc;
}
```


### 📌 @Retention

애노테이션이 유지되는 기간을 지정하는데 사용한다.

- `RetentionPolicy.CLASS`
  - 바이트 코드 파일까지 애노테이션 정보를 유지한다.
  - 리플렉션을 이용해서 애노테이션 정보를 얻을 수 없다.
- `RetentionPolicy.RUNTIME`
  - 바이트 코드 파일까지 애노테이션 정보를 유지한다.
  - 리플렉션을 이용해 런타임에 애노테이션 정보를 가져올 수 있다.
- `RetentionPolicy.SOURCE`
  - 컴파일 이후에는 삭제된다.

``` java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override{}
```

### 📌 @Documented

javadoc으로 작성한 문서에 포함시키려면 해당 애노테이션을 붙인다.

### 📌 @Inherited

애노테이션도 상속이 가능하다. 애노테이션을 자식 클래스에 상속하고자 할 때 사용한다.

``` java
@Inherited
@interface SuperAnno{}

@SuperAnno
class Parent{}

// <- 여기에 @SuperAnno 가 붙은 것으로 인식
class Child extends Parent{}
```

### 📌 @Repeatable

반복해서 붙일 수 있는 애노테이션을 정의할 때 사용한다.

``` java
@Repeatable(ToDos.class) // 컨테이너 애노테이션 지정
@interface ToDo{
	String value();
}

@ToDo("delete test codes.")
@ToDo("override inherited methods")
class MyClass{
	~~
}

@interface ToDos{
	ToDo[] value(); // value()를 여러 개 담을 수 있는 애노테이션
}
```

`MyClass`를 보면 `@ToDo` 애노테이션이 여러개가 정의된 것을 볼 수 있다.

`@Repeatable` 애노테이션은 위의 `ToDos`처럼 **컨테이너 어노테이션도 정의해야 한다.**


## 사용자 정의 애노테이션

``` java
@interface 애노테이션명{
	타입 요소 이름(); //애노테이션의 요소를 선언
	...
}
```

### 📌 애노테이션 규칙
- 요소의 타입은 원시타입, String, 열거타입, 애노테이션, 클래스만 허용된다.
- 괄호`()`안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소의 타입을 매개변수로 정의할 수 없다. `<T>`

``` java
@interface AnnoConfigTest{
    int id = 100; //됨
	String anno();

    String major(int i, int j); //안됨: 매개변수 x
    String minor() throws Exception; //안됨: 예외 x
    ArrayList<T> list(); //안됨: 요소의 타입을 매개변수 x
}
```

<br>

> 참고 <br>
> [1] https://hbase.tistory.com/169 <br>
> [2] https://velog.io/@jkijki12/annotation
