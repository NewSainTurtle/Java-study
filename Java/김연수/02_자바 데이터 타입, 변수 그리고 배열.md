## 1. 프리미티브 타입과 레퍼런스 타입

#### Primitive Type 

- 자바의 **기본형**으로 논리형과 문자형, 정수형, 실수형으로 8가지 타입.

- 실제 값을 저장하는 공간으로 **스택 메모리**에 저장.

- 기본 값이 있어 Null을 가질 수 없다.

- 데이터의 표현 범위를 벗어나면 컴파일 에러가 발생

-  제너릭 타입에서 사용할 수 없다.

<img alt="Primitive Type" src="https://github.com/NewSainTurtle/CS-study/assets/83412032/fe90b0a3-9cfb-4200-ad7a-17fd0e5c8144" width="50%">

#### Reference Type

- 자바의 **참조형** 타입, 기본형 타입을 제외한 타입들(배열, 열거, 클래스, 인터페이스)
- 값이 저장되어 있는 곳의 **주소 값**을 저장하는 공간으로 **힙 메모리**에 저장.
  - 객체 주소 값을 저장하는데 할당되는 메모리 크기는 4 byte이다.

- 빈 객체를 의미하는 Null이 존재한다.
- 런타임 에러가 발생
  - ex) 객체나 배열을 Null 값으로 받을 때 → NullPointException 발생
- 제너릭 타입에서 사용 가능

> **Generis Type**
>
> 제네릭은 리스트 자료형 같은 컬렉션 클래스나 메소드에서 사용할 내부 데이터 타입을 파라미터 주듯이 외부에서 지정하는 기법.
>
> `List<T> list = new ArrayList<>();`

<br>

## 2. 리터럴

**리터럴** : 변수에 넣는 변하지 않는 데이터, 그 자체를 의미한다.

`int a = 1;`

int 앞 a는 변수이고, 1은 리터럴이다. int 앞에 final을 붙이면 a는 상수가 된다.

> ***상수***는 리터럴과 같이 변하지 않는 고정 된 값을 의미 하지만, 상수는 변하지 않는 `변수`라는 점에서 리터럴과 다릅니다.

<br>

## 3. 변수 선언 및 초기화하는 방법

```java
int a; // 변수 선언
int a=3; // 변수 선언과 동시에 초기화
int a=0,b=0,c=0; // 같은 자료형일 경우 한 줄 선언 및 초기화 가능
Happy hap = new Happy(); // Happy라는 자료형 변수 선언과 동시에 새로운 객체를 생성하고 그 참조를 변수 안에 저장.
```

<br>

## 4. 변수의 스코프와 라이프타임

**변수의 스코프** : 변수에 접근하거나 접근할 수 있는 유효 범위/영역.

**변수의 라이프타임** : 변수가 메모리에서 살아있는 기간

> ##### 💡 변수 종류에 따른 스코프와 라이프타임
>
> - **인스턴스 변수** : 클래스 내부에서 선언되었지만 메서드 및 블록 외부에서 선언 된 변수를 인스턴스 변수
>
>   - 스코프 : 정적 메서드를 제외하고 클래스 전체
>
>   - 라이프타임 : 클래스의 객체가 메모리에 남을 때까지
>
> - **클래스 변수** : 클래스 내부, 모든 블록 외부에서 선언되고 static으로 선언된 변수를 클래스 변수
>
>   - 스코프 : 클래스 전체
>
>   - 라이프타임 : 프로그램이 종료 될 때까지
>
> - **지역 변수** : 인스턴스 또는 클래스 변수가 아닌 모든 변수를 지역 변수
>
>   - 스코프 : 블록 내에서 선언.
>
>   - 라이프타임 : 선언된 블록을 탈출하기 전까지

<br>

## 5. 타입 변환, 캐스팅 그리고 타입 프로모션

#### 타입변환

하나의 타입을 다른 타입으로 바꾸는 것을 말한다.

자바에서는 boolean을 제외한 나머지 기본 타입 간의 타입 변환을 자유롭게 수행 가능하다.

메모리에 할당 받은 바이트 크기가 상대적으로 작은 타입으로 타입 변환은 데이터 손실이 발생하여  컴파일러에서 이를 막고자 오류를 발생 시킨다.

#### 타입 변환의 종류

- **묵시적 타입 변환(자동 타입 변환, 프로모션)**
  
  > byte형 → short/char형 → int형 → long형 → float형 → double형
  
  - 컴파일러가 **자동**으로 수행 해주는 타입 변환
  
  - 상대적으로 크기가 작은 자료형을 더 큰 자료형에 대입할 때, 자동으로 **작은 자료형이 큰 자료형으로 변환**하는 것을 의미한다.
  
  - 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환 진행된다.

- **명시적 타입 변환(강제 타입 변환)**

  - 사용자가 타입 캐스트를 사용하여 **강제적**으로 수행하는 타입 변환
  - 실제 데이터 앞에 (데이터 자료형) 을 붙여주면 **캐스팅(형변환)**이 된다. 

  ```java
  int num=1;
  double ans = (double)num // 캐스팅을 통해 int를 double로 형변환
  ```
<br>

> 💡 **업 캐스팅과 다운 캐스팅**
>
> class Parent , class Child extends Parent 클래스가 있을 때,
>
> ```java
> Parent parent = (Parent) new Child(); // 업 캐스팅
> ```
>
> Child 클래스는 Parent 클래스를 상속 받으므로 Parent 클래스가 가지고 있는 데이터를 모두 가지고 있다.
>
> Child 입장에서 Parent의 정보를 모두 가지고 있으므로, 형변환 기호를 붙이지 않아도 실행 가능하다.
>
> ```java
> Child child = (Child) new Parent(); // 다운 캐스팅 (런타임 에러 발생)
> ```
>
> 위와 같이 형변환을 할 경우 컴파일러는 문법적으로는 에러를 발생하진 않지만, 참조형 데이터는 JVM이 Child의 성질을 추리하지 못하기  다운 캐스팅을 하더라도 런타임 오류가 발생한다.
>
> ```java
> Parent parent = new Child(); 
> Child child = (Child)parent; // 다운 캐스팅 성립
> ```
>
> 변수 parent는 Child 인스턴스 데이터를 가지고 있고 그 변수를 Child 클래스로 다운 캐스팅 한 것이다.
>
> 다운 캐스팅은 보통 성립하지 않지만, 위와 같이 업 캐스팅이 선행된 경우, 다운 캐스팅이 성립되는 경우가 존재한다.

<br>

## 6. 1차 및 2차 배열 선언하기

#### 배열

배열은 동일한 타입의 값을 여러 개 취급할 수 있는 기능으로, 배열 길이는 한번 생성하면 줄이거나 늘릴 수 없다.

인덱스라고 불리는 []로 감싼 0부터 시작하는 정수를 사용하여 배열의 길이나 순서를 나타낸다.

배열도 타입에 따라 default value로 채워진다.

#### 1차 배열 선언

```java
int[] array = new int[2]; // int타입으로 크기가 2인 배열 선언과 동시에 초기화, 기본값 0으로 세팅 됨
array[0] = 1; // array배열 0번째에 값 넣기
array[1] = 2; // array배열 1번째에 값 넣기
int[] array2 = {1, 2, 3, 4}; // 배열 선언과 동시에 값 세팅
```

#### 2차 배열 선언

```java
int [][]array = new int[2][2]; // int타입으로 크기가 2x2인 배열 선언과 동시에 초기화, 기본값 0으로 세팅 됨
array[0][0] = 1; // array배열 (0,0)번째에 값 넣기
array[1][0] = 2; // array배열 (1,0)번째에 값 넣기
int[][] array2 = {{1, 2}, {3, 4}}; // 배열 선언과 동시에 값 세팅
```
<br>

## 7. 타입 추론, var

**타입 추론** : 코드 작성 당시 타입이 정해지지 않았지만, 컴파일러가 그 타입을 유추하는 것

JAVA 10 이상으로 타입 추론을 지원하는 var 키워드가 추가되었다. 

이 키워드는 local variable 이면서 선언과 동시에 초기화가 필수적으로 요구된다.

```java
var name = "hihihi";
System.out.println(name.getclass().getName()); // java.lang.String으로 출력된다.

/**var과 다이아몬드 연산자를 같이 사용하게 되면 컴파일 에러가 발생 */
var name = new ArrayList<>(); // error
```
