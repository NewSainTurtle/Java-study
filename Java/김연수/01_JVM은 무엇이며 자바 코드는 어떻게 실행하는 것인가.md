## 1. JVM이란 무엇인가

JVM(**J**ava **V**irtual **M**achine)은 OS에 종속 받지 않고 CPU 가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터이다.

## 2. 컴파일 하는 방법

<img src="https://github.com/NewSainTurtle/CS-study/assets/83412032/24ea8afc-a6bd-4c45-9109-8680465d6c28" width="50%"/>

자바 코드(`*.java`)는 **Java compiler**를 통해 Java bytecode(`*.class`)로 변환된다.

 JVM은 OS가 bytecode를 이해할 수 있도록 해석 해준다. 

따라서 OS 상관없이 하나의 코드로  JVM을 통해 파일을 실행할 수 있다.

> **Java Compiler**는 JDK를 설치하면 `javac.exe`라는 실행 파일 형태로 설치된다.<br>
> Java Complier의 `javac` 라는 명령어를 사용하면 `.class` 파일을 생성할 수 있다.

## 3. 실행하는 방법

1. `.java` 파일을 생성
2. `cmd` 창을 열고 해당 `.java` 파일이 있는 곳으로 이동한다.
3. 해당 위치에서 `javac` 명령어로 컴파일을 진행하여 `.class` 파일이 생성한다.
4. `.class` 파일이 위치한 곳에서 `java <.class 파일 이름>` 을 입력해 JVM을 실행시킨다.
5. JVM은 바이트 코드들을 명령어 단위로 하나씩 가져와서 기계어로 변경하여 실행된다. 

## 4. 바이트 코드란 무엇인가

바이트코드는 가상 컴퓨터(VM)에서 돌아가는 실행 프로그램을 위한 이진 표현법이다.

자바 바이트 코드(Java bytecode)란 **자바 가상 머신이 이해할 수 있는 언어**로 변환된 자바 소스 코드를 의미한다.

바이트 코드는 다시 실시간 번역기 또는 JIT 컴파일러에 의해 바이너리 코드로 변환된다.

> **바이너리 코드란?** <br>컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드

> **기계어란?** <br>
>
> 0과 1로 이루어진 바이너리 코드이다.  <br>
> 기계어가 이진코드로 이루어졌을 뿐 모든 이진코드가 기계어인 것은 아니다.
> 기계어는 특정한 언어가 아니라 CPU가 이해하는 명령어 집합이다.

💡 **_CPU가 이해하는 언어는 바이너리 코드, 가상 머신이 이해하는 코드는 바이트 코드이다._**

## 5. JIT 컴파일러란 무엇이며 어떻게 동작하는지

JIT 컴파일러는 프로그램을 실제 실행하는 시점에 **기계어로 번역**하는 **컴파일러**이다.

인터프리터 방식의 단점을 보완하기 위해 도입되었다.

**바이트 코드 전체를 컴파일하여 기계어로 변경**하고, 이후에는 해당 더 이상 인터프리팅 하지 않고 **기계어로 직접 실행**하는 방식이다.

바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 **전체적인 실행 속도는 인터프리팅 방식보다 빠르다.**

> JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것보다 훨씬 오래걸리므로 한 번만 실행되는 코드라면 컴파일 하지 않고 인터프리팅하는 것이 유리하다.
>
> 따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넣을 때에만 컴파일을 수행한다.

## 6. JVM 구성 요소

1. **클래스 로더(Class Loader)**

   JVM 내로 클래스 파일(`*.class`)을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 

   런타임 시 `*.class`파일인 Java 바이트 코드를 읽어 들여 JVM의 메모리 영역(Runtime Data Area)에 적재한다. 

   즉, 처음 클래스에 접근할 때, 해당 클래스를 동적으로 로드하고 링크한는 역할을 한다.

2. **실행 엔진(Execution Engine)**

   Runtime Data Area에 적재된 클래스들의 바이트 코드들을 명령어 단위로 실행한다.

   실행 엔진은 인터프리터 방식과 JIT 컴파일러 방식으로 바이트 코드를 기계어로 변경한다.

3. **가비지 콜렉터(Garbage collector)**

   Runtime Data Area의 Heap 영역에 생성된 인스턴스들 중 더 이상 참조되지 않는 인스턴스를 정리한다. GC가 정확히 언제 역할을 수행하는지는 알 수 없으며 GC가 수행될 때 이를 제외한 모든 스레드는 일시정지된다. 

4. **런타임 데이터 영역 (Runtime Data Area)**

   Java 프로그램 실행 시 JVM에 할당되는 메모리 영역으로, 사용되는 데이터들을 적재하는 영역이다. 총 5개의 영역 Method Area, Heap Area, Stack Area, PC Register, Nagive Method Stack으로 나뉜다.

   - **Method Area (= Class Area = Static area)**

     클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간

   - **Heap Area**

     JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역

   - **Stack Area**

     프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역

   - **PC Register**

     Thread가 시작될 때 생성되며 생성될 때마다 생성되는 공간으로, 스레드마다 하나씩 존재한다. Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.

   - **Nagive Method Stack**

     자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역

   > **프로세스(process)란?**
   >
   > 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다.
   >
   > 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성된다.

   > **스레드(thread)란?**<br>
   >
   > 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미한다.
   >
   > 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
   >
   > 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스라고 한다.

## 7. JDK와 JRE의 차이

<img src="https://github.com/NewSainTurtle/CS-study/assets/83412032/3e37ebf9-1116-4f53-a16a-2b4e7670443c" width="50%"/>

### **JDK(Java Development Kit, 자바 개발 키트)**

> JRE + Development Tools(개발 툴)

Java 를 사용하기 위해 필요한 모든 기능을 갖춘 Java용 SDK (Software Development Kit)이다.

개발 시 필요한 라이브러리들과 컴파일러(javac)와 jdb, javadoc 등의 개발 도구들을 포함되어 있다.

JDK는 프로그램을 **생성, 실행, 컴파일**할 수 있다

### **JRE(Java Runtime Environment, 자바 런타임 환경)**

> JVM + 자바 클래스 라이브러리(Java Class Library)

자바 실행 환경으로, 자바로 만들어진 프로그램을 실행시키는데 필요한 라이브러리들과 각종 API, 그리고 JVM이 포함되어 있다. 

개발 관련 도구를 제공하지 않기 때문에 개발(쓰기)은 안되고 실행(읽기)만 가능하다.
  
컴파일 된 Java 프로그램을 **실행**할 수 있게 하는 도구이다.


💡 **_Java로 프로그램을 직접 개발하려면 JDK가 필요하고 Java로 만들어진 프로그램을 실행시키려면 JRE가 필요하다._**
