# 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

### 논리형

1. boolean
    - 크기 : 1 byte (8 bit)
    - 기본값 : false
    - 범위 : true, false

### 정수형

1. byte
    - 크기 : 1 byte (8 bit)
    - 기본값 : 0
    - 범위 : -128 ~ 127
2. short
    - 크기 : 2 byte (16 bit)
    - 기본값 : 0
    - 범위 : -32,768 ~ 32,767
3. int (기본)
    - 크기 : 4 byte (32 bit)
    - 기본값 : 0
    - 범위 : -2,147,483,648 ~ 2,147,483,647
4. long
    - 크기 : 8 byte (64 bit)
    - 기본값 : 0L
    - 범위 : 9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

### 실수형

1. float
    - 크기 : 4 byte (32 bit)
    - 기본값 : 0.0F
    - 범위 : (3.4 X 10-38) ~ (3.4 X 1038) 의 근사값
2. double(기본)
    - 크기 : 8 byte (64 bit)
    - 기본값 : 0.0
    - 범위 : (1.7 X 10-308) ~ (1.7 X 10308) 의 근사값

### 문자형

1. char
    - 크기 : 2 byte (16 bit)
    - 기본값 : '\u0000’
    - 범위 : 0 ~ 65,535
  
# 2. 프리미티브 타입과 레퍼런스 타입

### Primitive Type : 프리미티브(기본형) 타입

- 자바는 총 8가지의 기본형 타입을 미리 정의하여 제공한다.
- 모두 기본 값이 있어 Null이 존재하지 않는다.
- 기본형 타입에 Null을 넣고 싶다면 래퍼 클래스(Wrapper Class)를 활용해야 한다.
- 실제 값을 저장하는 공간으로 스택(Stack) 메모리 영역에 저장 된다.
- 각 타입의 데이터 범위를 벗어나면 컴파일 에러가 발생한다.
- 언어에서 사전 정의 되어있는 데이터 타입이다.
- 정수, 실수, 문자, 논리 리터럴 등의 실제 데이터 값을 저장하는 타입

### Reference Type : 레퍼런스(참조형) 타입

- 기본형을 제외한 나머지 타입들을 말한다. (ex. 문자열, 배열, 열거, 클래스, 인터페이스 등)
- 빈 객체를 의미하는 Null이 존재한다.
- 객체(Object)의 번지를 참조(주소를 저장) 하는 타입으로, 메모리 번지 값을 통해 객체를 참조하는 타입
- 값이 저장되어 있는 곳의 주소 값을 저장하는 공간으로 힙(Heap) 메모리에 저장된다.
- 자바 API에서 제공하거나 프로그래머에 의해 만들어진 클래스를 자료형으로 선언하는 경우
- 참조변수는 클래스 이름을 가지고 만들 수 있다.
- 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 런타임 에러가 발생한다.

### Primitive Type과 Reference Type의 차이점

- Null 포함 가능 여부
    - 기본형은 null을 담을 수 없지만, 참조형은 가능하다.
- 제너릭 타입에서 사용 가능 여부
    - 기본형은 제너릭 타입에서 사용할 수 없지만, 참조형은 가능하다.
- 기본형은 성능 상의 이점이 있다.
    1. 접근속도
        - 기본형은 스택 메모리에 값이 존재한다.
        - 하지만 참조형은 하나의 인스턴스이기 때문에 스택 메모리에 참조값만 있고, 실제 값은 힙 메모리에 존재한다.
        - 그리고 값을 필요로 할 때마다 언박싱 과정을 거쳐야 해서 기본형보다 접근속도가 느리다. (언박싱 = 참조형을 기본형으로 변환시키는 것)
        - 예외로 엄청 큰 숫자를 복사해야 한다면, 참조값만 넘길 수 있는 참조타입이 좋을 수도 있다.
    2. 메모리 양
        - 기본형보다 참조형이 사용하는 메모리양이 압도적으로 높다.

    |원시타입이 사용하는 메모리|참조타입이 사용하는 메모리|
    |---|---|
    |boolean - 1bit        | Boolean – 128 bits         |
    |byte - 8bits          |	Byte - 128bits            |
    |short, cagr - 16bits  |	Short, Charater - 128bits |
    |int, float - 32bits   |	Integer, Float - 128bits  |
    |long, double - 64bits |	Long, Double - 196bits    |

# 3. 리터럴

- 프로그램에서 직접 표현한 값
- 소스 코드의 고정된 값을 대표하는 용어
- 종류로는 정수, 실수, 문자, 논리, 문자열 리터럴이 있다.

### 정수 리터럴

```java
int a = 15;  // 10진수 15
int b = 015; // 0으로 시작하면 8진수, 십진수 13
int c = 0x15; // 0x로 시작하면 16진수, 십진수 21
int d = 0b0101; // 0b로 시작하면 2진수, 십진수 5

// long타입 리터럴은 숫자 뒤에 L또는 l을 붙인다.
long e = 26L;
```

### 실수 리터럴

```java
double a = 0.1234;
double b = 1234E-4;
//1234*10*(-4)이므로 0.1234와 동일

// 숫자 뒤에 f나 d를 명시적으로 붙여 각각 float과 double 표현
float c = 0.1234f;
double d = 0.1234D;
```

### 문자 리터럴

```java
// 문자 리터럴은 단일 인용부호('')로 문자를 표현한다.
char a = 'H';
char b = '한';

// \u 다음에 4자리 16진수로, 2바이트의 유니코드(Unicode)
char c = '\uae00'; (유니코드 값)
```

![Untitled (1)](https://github.com/NewSainTurtle/CS-study/assets/63511273/91558af5-a001-4665-ab04-9974c173eb48)

### 문자열 리터럴

```java
// 문자열은 기본타입이 아니며, 더블 쿼터("")로 문자열을 표현한다.
String s = "JAVA";
s = s + 24;  // JAVA24 출력
```

### 논리 타입 리터럴

```java
boolean a = true;
boolean b = 10 > 0; // b의 값은 true
boolean c = 0;  // error
// C언어와 달리 boolean 타입으로 1,0을 참, 거짓으로 사용 불가
```

### null 리터럴

```java
// null 리터럴은 기본형에서는 error 발생, 참조형은 사용이 가능
int a = null; // error

String str = null; // 가능
```

# 4. 변수 선언 및 초기화 하는 방법

### 변수 선언(Declare)

- 값(데이터)을 사용하려면 변수를 선언 해야 한다.
- 변수를 선언하는 이유는 값을 저장하는 공간을 확보하기 위함이다.
- 정확히 컴퓨터가 가진 메모리를 사용하겠다고 미리 컴퓨터에게 말하는 것이다.
- 미리 자원을 확보하는 동시에 메모리를 사용한다는 의미를 가지고 있기 때문에, 변수를 선언하지 않는다면 프로그램은 값(데이터)을 담아둘 공간이 없어 값을 사용할 수 없다.

### 변수를 선언하는 방법

- 변수를 선언하기 위해서는 변수 타입과 변수명을 함께 작성한다.

```java
int num;  // 타입 : int, 변수명 : num
String message;  // 타입 : String, 변수명 : message
boolean flag;  // 타입 : boolean, 변수명 : flag
```

- 변수 타입은 변수에 담는 값과 직접적인 연관이 있다.
- 즉, 어떤 값을 변수에 담느냐에 따라 변수 타입도 달라져야 한다.
- 변수 값과 타입은 서로 같지 않으면, 담을 수 없다.

### 변수명 짓는 규칙

- Keyword는 사용할수 없다. [ ex. true(x), True(o) ]
- 첫글자는 숫자로 시작할 수 없다. [ ex. 1step(x), step1(o) ]
- 특수문자는 ‘_’ , ‘$’ 만 사용할 수 있다. [ ex. %step(x), _step(o) ]
- 대소문자는 구별되며 길이에 제한을 두지는 않는다. [ ex. num과 Num은 다르다 ]
- 자바에서 권장하는 규칙
    - 클래스 명의 첫 글자는 대문자로 한다.
    - 메서드명, 변수명의 첫 글자는 소문자로 한다.
    - 1개 이상의 단어로 이루어진 경우 단어의 첫 글자는 대문자로 한다. [ ex. countOfWords ]
    - 상수의 이름은 모두 대문자로 하며, 1개 이상의 단어로 이루어진 경우 “_”로 구분한다. [ ex. COUNT_OF_WORDS ]

### 변수 초기화(Initialize)

- 값(데이터)을 사용하기 위해서는 변수를 선언한 후 값을 할당해주어야 한다.
- 기본적으로 변수는 선언과 초기화가 이루어져야 된다.
- 경우에 따라서는 초기화하지 않고 사용할 수도 있지만, 가능하면 선언과 동시에 적절한 값으로 초기화하는 것이 바람직하다.

```java
멤버 변수 초기화 : 초기화를 하지 않아도 자동적으로 변수 자료형의 기본값으로 초기화가 이루어짐.
지역 변수 초기화 : 반드시 초기화를 하고 사용해야 한다.
```

### 변수 초기화하는 방법

```java
// 변수 선언
int num;
String message;
boolean flag;

// 변수 초기화
num = 10;
message = "JAVA";
flag = true;

// 변수 선언 및 초기화
int num2 = 11;
String message2 = "Hello";
boolean flag2 = false;

// 다중 변수 선언도 가능
int x1, x2, x3;
```

# 5. 변수의 스코프와 라이프 타임

### 변수의 스코프

- 프로그램상에서 사용되는 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의 스코프라고 한다.
- 일반적인 규칙은 변수가 선언된 블록 { } 내에서만 변수에 접근할 수 있다.
- 스코프는 변수가 선언되는 영역에 따라 접근하는 방법이 다르다.

### 변수의 라이프 타임

- 변수가 유효한 시간을 말한다.
- 프로그램이 구동되는 동안 변수가 값을 담고 있을 수 있는 주기를 말한다.
- 변수의 종류에 따라 상이하기 때문에 각각의 차이를 이해하는 것이 중요하다.

### 선언 위치에 따른 변수의 종류

- 자바에서의 변수는 클래스 변수, 인스턴스 변수, 지역 변수가 있다.
- 변수의 종류를 결정짓는 것은 ‘변수가 선언된 위치’이다.

```java
public class test {
	int x;  // 인스턴스 변수
	static int y;  // 클래스 변수
	
	void method() {
		int z;  // 지역 변수
	}
}
```

- 멤버 변수 : 클래스 내부에 선언된 x, y
- x : 인스턴스 변수, y : static으로 선언되어 클래스 변수
- 지역 변수 : 메서드 내에 선언된 z

| 변수의 종류 | 선언 위치 | 생성시기(메모리 할당 시기) |
| --- | --- | --- |
| 클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성 될 때 |
| 지역 변수 | 클래스 이외의 영역 (메서드, 생성자, 초기화 블럭) | 변수 선언문이 수행 되었을 때 |

### 인스턴스 변수

- 인스턴스가 생성될 때 생성된다.
- 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 먼저 생성해야 한다.
- 인스턴스 별로 다른 값을 가질 수 있어, 각각의 인스턴스마다 고유의 값을 가져야할때 선언 한다.

### 클래스 변수

- 인스턴스 변수에 static을 붙인다.
- 모든 인스턴스가 공통된 값을 공유하게 된다.
- 클래스가 로딩될때 생성된다. 그러므로 메모리에 딱 한번만 올라간다.
- public을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역변수가 된다.
- 인스턴스 변수와는 다르게 인스턴스를 생성하지 않고 클래스이름.클래스변수명을 통해서 접근할 수 있다.

### 지역 변수

- 메서드 내에서 선언된다.
- 메서드 내에서만 사용할 수 있는 변수
- 메서드가 실행 될 때 메모리를 할당 받으며 메서드가 끝나면 소멸되어 사용할 수 없게 된다.

| 변수의 종류 | 스코프 | 라이프 사이클 |
| --- | --- | --- |
| 클래스 변수 | 클래스 전체 | 클래스가 메모리에 올라간 후 프로그램이 끝낼 때 까지 |
| 인스턴스 변수 | static 블록과 static 메서드를 제외한 클래스 전체 | 인스턴스가 생성 후 메모리에 살아있을 때 까지 |
| 로컬 변수 | 변수가 선언된 블록 내부 | 변수 선언 후 블록을 벗어날 때 까지 |

# 6. 타입 변환, 캐스팅 그리고 타입 프로모션

- 자바의 기본형에서는 프로모션과 캐스팅이 발생한다.

### 프로모션 (묵시적 형 변환)

- 작은 데이터 타입에서 큰 데이터 타입으로 형 변환 되는 것

### 캐스팅 (명시적 형 변환)

- 큰 데이터 타입에서 작은 데이터 타입으로 형 변환 되는 것

### 데이터 타입 크기 순서

- [큰] double(8) - float(4) - long(8) - int(4) - short, char(2) - byte(1) [작은] 순서이다

```java
int n = 10;
	
long l = n;  // 자동 형변환 (Promotion)

byte b1 = n;  // error

byte b2 = (byte)n; // 강제 형변환 (Casting)
```

- 단, 음수가 저장될 수 있는 byte, int 등의 타입은 char타입으로 자동 변환 될수 없다.

### 연산시 자동 타입 변환

- 정수와 실수 연산 = 실수형 타입(double)
- 정수와 정수 연산 = int 타입
- 실수와 실수 연산 = double 타입
- 큰 타입과 작은 타입 연산 = 큰 타입

# 7. 1차 및 2차 배열 선언하기

### 1차 배열 선언하는 방법

```java
int[] arr1;
int []arr2;
int arr3[];
```

- 위에서 예시든 int가 아닌 다른 타입을 사용할수 있다.
- 현재 이상태는 공간(메모리)을 차지하지 않는다.
- 배열을 초기화하면서 사이즈를 정해줘야 공간(메모리)을 차지하게 된다.

### 1차 배열 초기화하는 방법

```java
int[] arr;

arr = new int[3];
```

- arr이라는 배열을 선언하고, int타입의 사이즈가 3인 배열로 초기화 하였다.
- 이렇게 초기화하면 int의 기본값인 0으로 초기화 되어 있다.

### 선언과 초기화를 동시에 하는 방법

```java
int[] arr1 = new int[3];
int []arr2 = new int[3];
int arr3[] = new int[3];
```

### 직접 값을 초기화 하는 방법

```java
int[] arr1 = new int[3];

// 각각의 index에 값을 넣어줄수 있다.
arr1[0] = 0;
arr1[1] = 1;
arr1[2] = 2;

arr1 = {0,1,2};  // error

//한번에 값을 넣어 주고 싶다면 선언과 동시에 해야 한다.
int[] arr2 = {0,1,2};
int[] arr3 = new int[]{0,1,2};
```

### 2차원 배열 선언하기

```java
int[][] arr;

//1차원 배열과는 다르게 아래 방법은 error 발생
int [][]arr;
int arr[][];
```

### 2차원 배열 초기화하기

```java
int[][] arr = new int[3][3];

arr[0][0] = 0;
arr[0][1] = 1;
arr[0][2] = 2;
arr[1][0] = 3;
...

// ㅇ개별 1차원 Array의 길이가 다른 2차원 배열도 생성 가능하다.
int[][] arr2 = new int[3][];
arr2[0] = new int[1];
arr2[1] = new int[2];
arr2[2] = new int[3];
```

```java
//선언과 초기화를 동시에 하기
int[][] arr = {{1,2,3},{0,1,2}};

int[][] arr2 = new int[3][];
arr2[0] = new int[]{1};
arr2[1] = new int[]{1,2};
arr2[2] = new int[]{1,2,3};
```

# 8. 타입 추론 - var

- Java10 부터 type - inference(타입 추론)이 된다.

### 타입 추론

- 타입 추론이란 개발자가 변수의 타입을 명시적으로 적어주지 않아도, 컴파일러가 알아서 이 변수의 타입을 대입된 리터럴로 추론하는 것
- 대표적인 타입추론 언어는 javascript, kotlin, swift 등이 있다.

```java
// 자바 10 전까지 쓰던 기존의 변수 선언
String str = "Java";

// 타입추론을 사용한 변수 선언
var str2 = "Java";
if(str2 instanceof String) // true가 된다.
```

- 타입 추론을 사용하면 앞에 변수의 타입을 따로 명시하지 않아도 된다.
- 단, var라는 키워드를 선언 해준다.
- 컴파일 시점에 컴파일러가 초기화값 리터럴로 타입을 추론한다.

### 타입추론의 특징

1. var는 초기화값이 있는 지역변수로만 선언이 가능하다.
    - var는 멤벼변수, 또는 메소드의 파라미터, 리턴 타입으로 사용이 불가능 하다.
    - 초기화 값이 무조건 있어야 한다.
2. var는 키워드(Keyword)가 아니다.
    - 어떠한 타입도 아니고, 클래스에서 사용할 수 있는 예약어가 아니다.
    - 그래서 var라는 문자를 변수명으로 사용할 수 있다. [ ex. int라는 변수명은 사용하지 못한다. ]
    - 위 내용이 가능한 이유는 컴파일러가 바이트 코드로 변경할 떄, var에는 타입이 명시되어 진다.
    - 즉, 컴파일 후에 바이트코드를 까보면 var는 해당하는 type으로 되어있다.
3. var는 런타임 오버헤드가 없다.
    - 컴파일 시점에 var는 초기화된 값을 보고 타입이 정해진다.
    - 타입추론 변수를 읽을때 마다 타입을 알아내기 위한 연산을 계속 수행하지 않는다는 것이다.
    - 그래서 var로 선언된 변수는 중간에 타입이 절대 변경되지 않는다.
    - 예외로 자바스크립트 같은 언어에서는 중간에 다른 값으로 변경할 수 있다.

```java
var i = 3;

i = "hello";  //컴파일단에서 바로 error 발생
```

### var의 잘못된 사용법

- var는 초기화 없이 사용할 수 없다.

```java
// var 타입은 초기화 값을 선언부에 명시해줘야 한다.
var i;  // error
```

- var 타입 변수에는 null값이 들어갈 수 없다.

```java
// var 타입의 초기화 값은 null이 될수 없다.
var i = null; // error
```

- var 타입은 로컬 변수에만 선언이 가능하다.

```java
// 멤버 변수에 사용하지 못한다.
private var i = "Hello";  //error
```

- Lambda Expression에는 명시적인 타입을 지정해줘야 한다.

```java
var p = (String s) -> System.out.println("s = "+s);
```

- 배열을 선언할 때, var 대신 타입을 명시해줘야 한다.

```java
// 배열 선언할 때 타입을 명시해줘야 한다.
var arr = {1,2,3};  // error
```

### var 활용

```java
Consumer<String> test = s -> System.out.println("s = "+s);
// 위 람다식을 var로 사용한다면 아래와 같이 바꿀 수 있다.
Consumer<String> test = (var s) -> System.out.println("s = "+s);
// 이렇게 쓰는 이유는 아래와 같이 키우드 앞에만 사용할 수 있는 어노테이션을 사용 할 수 있기 때문이다.
Consumer<String> test = (@Nonnull var s) -> System.out.println("s = "+s);
```

> [백기선님 강의 참고](https://www.youtube.com/watch?v=tjj-XLk4CSA)

참고
> [1] (https://velog.io/@gillog/%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85Primitive-Type-Reference-Type)</br>
> [2] (https://mine-it-record.tistory.com/100#google_vignette)</br>
> [3] (https://7942yongdae.tistory.com/22#google_vignette)</br>
> [4] (https://hyunsdevnote.tistory.com/9)</br>
> [5] (https://kephilab.tistory.com/27)</br>
> [6] (https://www.techiedelight.com/ko/declare-initialize-two-dimensional-2d-arrays-java/)</br>
> [7] (https://catch-me-java.tistory.com/19)</br>
