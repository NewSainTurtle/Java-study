# 1. 자바 상속의 특징

### 상속

- 자식 클래스(Sub Class)가 부모 클래스(Super Class)의 기능을 그대로 물려받아 사용할 수 있는것을 말한다.
- 캡슐화, 추상화, 다형성과 더불어 상속은 객체지향프로그래밍 특징 중 하나이다.

### 상속의 특징

- 상속은 클래스 간의 관계가 Is-a일때 사용하는 것이 좋다.
- Is Like a 관계가 되지 않도록 주의해야한다.
1. 자바의 클래스는 단일상속이 원칙이다. 다중상속이 불가능하다.
    - 다중상속을 허용하면 모호성(ambiguous)이 발생하기 때문에 허용하지 않는다.
    - 자식 클래스는 하나의 부모 클래스만 가질 수 있다. (자식은 몇개이든 상관 없다.)
    - 인터페이슨느 다중상속을 허용한다.
2. 자바에서 계층구조의 최상위에는 java.lang.Object 클래스가 있다.
    - 자바에서 모든 클래스는 Object() 클래스를 자동으로 상속받게 되어있다. 그래서 equals(), toString()과 같은 메소드를 바로 사용할 수 있다.
- * 자식 클래스의 첫 번째 줄에는 항상 부모의 생서자를 호출하는 super() 메소드가 존재한다. 그래서 최상위 클래스의 생성자부터 만들어지게 된다.
1. 자바에서는 상속의 횟수에 제한을 두지 않는다.

### 상속의 장점

1. 코드의 중복성이 제거된다.
    - 자식 클래스들의 공통적인 부분을 부모 클래스에서 한번만 정의하기 때문에 코드가 간결해진다.
    - 부모 클래스의 메소드를 자식 클래스에서 본인의 메소드처럼 사용할 수 있어 편리하다.(오버라이딩)
    - 기존 클래스의 변수와 코드를 재사용하기 때문에 개발 시간이 단축된다.
    - 먼저 작성된 검증된 프로그램을 재사용하기 때문에 신뢰성 있는 개발을 할 수 있다.
2. 다형적 표현이 가능하다. (=다형성)
    - 하나의 객체를 다양하게 표현할 수 있어 확장성이 좋다.
    - 클래스 간의 계층적 분류 및 관리가 가능하여 유지보수성이 좋다.

### 상속 선언

```jsx
public class Animal() {
	public void eat() {
		System.out.println("먹다.");
	}
}
```

- 상속을 선언할 때는 extends 키워드를 사용한다.

```jsx
public class Tiger extends Animal{
	public void attack() {
		System.out.println("공격하다.");
	}
}
```

- Tiger 클래스는 부모 Animal 클래스를 상속받았기에 eat() 메소드를 작성하지 않았지만 사용할 수 있다.
- attack() 메소드 처럼 부모 클래스의 기능에 추가적인 기능 구현을 할 수 있다.

### 서브 클래스 객체

```jsx
Animal a1 = new Animal();
a1.eat();

Tiger a2 = new Tiger();
a2.eat();
a2.attack();
```

# 2. super 키워드

### 1. 부모의 객체를 가리키는 super 키워드

- super 키워드는 부모의 객체를 가리키는 것
- 필드명의 중복 또는 메소드 오버라이딩으로 가려진 부모의 필드 또는 메소드를 호출하기 위해 사용한다.

```java
class A {
	void print() {
		System.out.println("A클래스 입니다.");
	}
}
class B extends A {
	void print() {
		System.out.println("B클래스 입니다.");
	}
	void printB() {
		print();  //this.print();
	}
}
public class Test {
	public static void main(String[] args) {
		B b = new B();  // 객체 생성
		
		b.printB();  // 메소드 호출
	}
}
```

- b.printB() 실행 시 B클래스의 print()가 실행 되어 “B클래스 입니다.”가 출력 된다.
- 인스턴스 메소드의 내부에서 모든 필드와 메서드 앞에는 자동으로 컴파일러가 this 키워드를 추가하여 컴파일 하기 때문이다.

```java
class A {
	void print() {
		System.out.println("A클래스 입니다.");
	}
}
class B extends A {
	void print() {
		System.out.println("B클래스 입니다.");
	}
	void printB() {
		super.print();  // 부모 클래스 객체의 print() 메소드 호출
	}
}
public class Test {
	public static void main(String[] args) {
		B b = new B();  // 객체 생성
		
		b.printB();  // 메서드 호출
	}
}
```

- 부모 클래스의 print() 메소드를 자식 클래스에서 호출하기 위해서는 super키워드를 사용하면 된다.
- 위 실행 결과는 부모인 A클래스의 print() 메소드가 실행되어 “A클래스 입니다.”가 출력 된다.

### 2. 부모 클래스의 생성자를 호출하는 super() 메소드

- 부모 클래스를 상속받은 자식 클래스가 생성자를 이용해 객체를 생성할때 항상 부모 클래스 객체가 먼저 생성된다.
- super() 메소드를 이용하여 부모 클래스의 생성자를 호출할 수 있기때문이다.
- this()와 마찬가지로 생성자의 내부에서만 사용할 수 있고, 반드시 첫 줄에 와야 한다.
- 그래서 this() 메소드와 첫줄에 올 수 있는 경우가 겹치므로, 둘을 1개의 생성자 안에서 절대 함께 쓸 수 없다.

```java
class A {
	A() {
		System.out.println("A생성자");	
	}
}
class B extends A {
	B() {
		super();
		System.out.println("B생성자");
	}
}
```

- B b = new B()로 B() 생성자로 객체를 생성했을 때의 메모리 구조는 다음과 같다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c382dab5-8fe3-4ab5-9fe3-3ddc063f5737/Untitled.png)

- B() 생성자를 이용해 객체를 생성할 때는 가장 먼저 super() 메소드를 실행한다.
- super() 메소드는 부모 생성자인 A()가 실행된다.
- A() 생성자의 실행이 완료되면 메모리에는 A 객체가 생성된다.
- 이후 B() 메소드로 돌아와 나머지 코드가 실행된다.
- 즉, 위 코드에서 B 객체 생성시 “A생성자”, “B생성자” 순으로 출력 된다.
- * 첫줄에는 반드시 this() 또는 super() 가 있어야한다.
- 아무것도 써주지 않으면 컴파일러는 super()를 자동으로 추가한다.
- 즉, 생성자를 호출할 때는 항상 부모 클래스의 생성자가 한번은 호출 된다.
