# 1. 산술 연산자

- 사칙연산을 다루는 연산자
- 가장 기본적이고, 가장 많이 사용되는 연산자 중 하나이다.
- 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.

(이항 연산자란? 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자란 의미)

| 산술 연산자 | 설명 |
| --- | --- |
| + | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함. |
| - | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌. |
| * | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함. |
| / | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔. |
| % | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |
- boolean 타입을 제외한 모든 기본 타입에 사용 가능

# 2. 비트연산자

- 피연산자를 비트단위로 논리 연산한다.
- 비트 연산을 하기 때문에, 0과 1로 표현이 가능한 정수 타입이나 정수형 캐스팅이 가능한 자료형만 비트 연산이 가능하다.

### 비트 이동 연산자 (<<, >>, >>>)

| 연산식 | 설명 |
| --- | --- |
| x << y | 정수 x의 각 비트를 y만큼 왼쪽으로 이동시킵니다. (빈자리는 0으로 채워집니다.) |
| x >> y | 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킵니다. (빈자리는 정수 a의 최상위 부호비트와 같은 값으로 채워집니다. |
| x >>> y | 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킵니다. (빈자리는 0으로 채워집니다.) |
- 비트 이동 연산자는 정수 데이터의 비트를 이동 시키는 연산이다.

```jsx
2 << 3  // 결과 : 16
// 00000000 00000000 00000000 00000010 // 2
// << 3
// 00000000 00000000 00000000 00010000 // 16

16 >> 3  // 결과 : 2
// 00000000 00000000 00000000 00010000 // 16
// >> 3
// 00000000 00000000 00000000 00000010 // 2

-16 >> 3  // 결과 : -2
// 11111111 11111111 11111111 11110000 // -16
// >> 3
// 11111111 11111111 11111111 11111110 // -2

-16 >>> 3  // 결과 : 536870910
// 11111111 11111111 11111111 11110000 // -16
// >>> 3
// 00011111 11111111 11111111 11111110 // 536870910
```

### 비트 논리 연산자 (&, |, ^, ~)

| 연산자 | 논리 | 설명 |
| --- | --- | --- |
| & | AND | 두 비트 모두 1일 경우에만 연산 결과가 1 |
| | | OR | 두 비트 중 하나만 1일 경우에만 연산결과가 1 |
| ^ | XOR | 두 비트중 하나는 1이고 다른 하나가 0일경우에만 연산결과가 1 |
| ~ | NOT | 비트 반전(보수) |
- 비트 논리 연산자는 대상이 boolean타입일 경우에는 일반 논리 연산자로 활용된다.
- 대상이 정수형일 경우에는 위 표와 같이 비트 논리 연산자로 활용된다.
- 비트 연산은 두 값을 비트 단위로 나열한 뒤 각 자릿수를 비트 연산자로 연산한다.
- 각 자릿수의 연산은 독립적이며 다른 자릿수에 영향을 주지 않는다.

#### & (AND 연산)

```java
// &연산결과
0 0 0 0 1 1 1 1 // 15 
0 0 0 1 1 0 0 1 // 25
0 0 0 0 1 0 0 1 // & 연산결과 : 9
```

- & 연산(논리곱)은 2진수로 표현된 두 비트가 모두 1일 경우에만 연산결과가 1로 표현된다.

#### | ( OR 연산)

```java
// |연산결과
0 0 0 0 1 1 1 1 // 15
0 0 0 1 1 0 0 1 // 25
0 0 0 1 1 1 1 1 // | 연산결과 : 31
```

- | 연산(논리합)은 2진수로 표현된 두 비트 중 하나라도 1일 경우 연산결과가 1로 표현된다.

#### ^ (XOR 연산)

```jsx
// ^연산 결과
0 0 0 0 1 1 1 1 // 15
0 0 0 1 1 0 0 1 // 25
0 0 0 1 0 1 1 0 // ^ 연산결과 : 22
```

- ^ 연산(배타적 논리합)은 2진수로 표현된 두 비트 중 하나는 1이고 다른 하나가 0일경우에 연산결과가 1로 표현된다. (1^1은 0이다.)

#### ~ (보수)

```jsx
// ~연산 결과
0 0 0 1 1 0 0 1 // 25
1 1 1 0 0 1 1 0 // ~ 연산결과 : -26
```

- ~ 연산(논리부정)은 2진수로 표현된 피연산자의 값을 반전(보수)시켜주어 표현한다.

# 3. 관계 연산자

- 비교 연산자
- 결과가 boolean타입인 true 혹은 false 값으로 반환된다.
- 조건문, 반복문의 조건식으로 많이 사용된다.

| 연산자 | 기능 | 예 |
| --- | --- | --- |
| > | 왼쪽 항이 크면 참, 아니면 거짓을 반환합니다. | num > 3; |
| < | 왼쪽 항이 작으면 참, 아니면 거짓을 반환합니다. | num < 3; |
| >= | 왼쪽항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓을 반환합니다. | num >= 3; |
| <= | 왼쪽항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓을 반환합니다. | num <= 3; |
| == | 두 개 항의 값이 같으면 참, 아니면 거짓을 반환합니다. | num == 3; |
| != | 두 개 항이 다르면 참, 아니면 거짓을 반환합니다. | num != 3; |

# 4. 논리 연산자 (&&, ||, !)

- 관계 연산자와 같이 사용 되는 경우가 많다.
- 연산의 결과가 true 혹은 false로 반환 된다.

| 연산자 | 기능 |
| --- | --- |
| && (논리 곱) | 두 항이 모두 참인 경우에만 결과 값이 참이다. 그렇지 않은 경우는 거짓이다. |
| || (논리 합) | 두 항 중 하나의 항만 참이면 결과 값은 참이다. 두 항이 모두 거짓이면 결과 값은 거짓이다. |
| ! (부정) | 단 항 연산자이다. 참인 경우는 거짓으로 바뀌고, 거짓인 경우는 참으로 바뀐다. |

```java
// && 연산 예시
(5>3) && (5>2); //true
(5<3) && (5>2); //fasle, &&앞에 있는 조건식이 false라면 뒤의 조건식을 확인하지 않아도 false이므로 뒤의 조건식은 확인하지 않는다. (단락회로평가)

// || 연산 예시
(5>3) || (5>2); //true, ||앞의 조건식이 true이므로 뒤의 조건식을 확인하지 않아도 true가 되기 때문에 뒤의 조건식을 확인하지 않는다.
(5<3) || (5<2); //false

// ! 부정 예시
!(5>3); //false
!(5<3); //true
```

### 단락회로평가

- 위의 예시 경우에서 처럼 논리 연산자를 활용하여 연산하는 과정에서, 앞 식의 결과값으로 인해서 전체조건의 결과가 판단된다면, 뒤의 식을 연산하지 않는 것을 말한다.

# 5. Instanceof

- 객체타입을 확인하는 연산자
- 형변환 여부를 확인하며 true/ false로 결과를 반환한다.
- 주로 상속 관계에서 부모객체인지 자식 객체인지 확인하는 데 사용된다.
- 기본 사용법은 “객체 instanceof 클래스”를 선언함으로써 사용한다.

```java
// Child 클래스는 Parents 클래스를 상속받았다고 가정
class Parents {}
class Child extends Parents {}
```

```java
Parents parents = new Parents();
Child Child = new Child();

System.out.println(parents instanceof Parents); // 1. true
System.out.println(child instanceof Parents);   // 2. true
System.out.println(parents instanceof Child);   // 3. false
System.out.println(child instanceof Child);     // 4. true
```

1. parents instanceof Parents : 부모는 부모타입이므로 true
2. child instanceof Parents : 자식은 부모로부터 상속받았으므로 부모타입도 되므로 true
3. parents instanceof Child : 부모는 자식타입이 되지는 못하므로 false
4. child instanceof Child : 자식은 자식타입이므로 true

* 형 변환이 불가능한, 즉 타입이 상위 클래스도 하위 클래스도 아닐 경우 에러 발생

### Instanceof 의 사용을 지양하자

#### 1. 캡슐화

- instanceof를 사용하는 경우, 각 객체가 무엇인지 불필요한 외부의 객체가 그 정보를 알게 되어 캡슐화가 깨진다.
- 각 객체가 가진 책임과 역할을 분리해주고, 이로 인해 유지보수, 확장에 있어 편리함을 얻기 위해 객체지향프로그래밍을 한다. 캡슐화가 보장 되지 않으면 그 의미가 없어진다.

#### 2. Open Closed Principle

- 다형성을 이용하면 새로운 객체를 만들고 그 객체에 구현하면 된다.
- instanceof를 사용하는 경우 새로운 메서드를 만들어주기 위해 사용되고 있는 모든 함수를 고쳐야한다.
- 이는 객체이 확장이 어려워진다는 문제점이 있다.
- 객체의 확장에는 열려있고, 변화에는 닫혀있도록 해야한다는 개방-폐쇄 원칙(OCP)에 위반됨을 알 수 있다.

#### 3. Single Resopnsibility Principle

- instanceof가 사용되는 이유는 특정 타입임을 알아내고 특정 코드를 실행하기 위해서이다.
- instanceof를 사용하여 특정 코드를 실행하기 위해선 타입을 확인하는 모든 객체의 메서드 구현을 알고 있어야 하는 책임이 부가 된다.
- 각 타입에게 책임을 부여하면 되는 일이 하나의 메서드에게 모든 책임이 가중되는 일이 발생한 것이다.
- 한 클래스는 하나의 책임만 가져야 한다는 객체지향 프로그램이의 원칙 중 하나인 단일책임원칙(SRP)이 위반된 것이라고 볼 수 있다.
  

#### 4. 성능

- 서로 다른 구현이 필요한 경우에 다형성을 적용한 구현을 하게 되면 컴파일러는 어떠한 타입의 메서드를 실행해야 할지 알 수 없으므로 invokevirtual 바이트코드를 이용해 메서드에 대한 가상의 호출을 한다. 이 후 런타임에 특정 타입을 찾아 그에 맞는 구현을 실행한다.
- 반면 instanceof를 적용한 경우 알맞은 타입을 찾을 때 까지 컴파일 시에 모든 타입을 돌며 검사해야 한다.
- 이로 인해 다형성을 적용한 성능이 instanceof를 검사하는 성능보다 빠르다.
- 심지어 확인해야할 객체가 많으면 많을수록 불필요한 instanceof 검사가 더 필요하고 성능의 차이는 점차 커진다.

#### 5. 깔끔한 구현, 쉬운 리펙토링

- 다형성을 이용한 구현은 if분기문이 많이 필요없다.
- instanceof를 사용했을 때 여러 if문이 발생하는 것 보다 코드가 깔끔하고 간단하다.
- 또한, instanceof는 상속 구조가 바뀌어버리면 관련 코드는 모두 수정이 필요하다.
- 하지만 다형성을 적용했을 때는 구조가 바뀌더라도 그 바뀐 타입의 메서드만 수정해주면 되므로 리펙토링이 쉬워진다.


# 6. 대입 연산자(Assignment Operator)

- 변수에 값을 대입할 때 사용하는 연산자
- 연산은 기본적으로 오른쪽에서 왼쪽으로 결합하게 된다.
- 대입할 때 산술연산자를 결합한 대입 연산자를 활용하기도 한다.
- 연산과 동시에 대입하는 대입 연산자는 복합 대입 연산자라고 한다.

| 대입 연산자 | 설명 |
| --- | --- |
| = | 오른쪽의 값을 왼쪽에 대입합니다. |
| += | 오른쪽의 값을 더해주면서 왼쪽에 대입합니다. |
| -= | 오른쪽의 값을 빼주면서 왼쪽에 대입합니다. |
| *= | 오른쪽의 값을 곱해주면서 왼쪽에 대입합니다. |
| /= | 오른쪽의 값을 나누면서 왼쪽에 대입합니다. |
| %= | 오른쪽의 값을 나눈 후 나머지는 왼쪽에 대입합니다. |
| &= | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
| |= | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
| ^= | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
| <<= | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
| >>= | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
| >>>= | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |

# 7.  화살표(->) 연산자

- 람다 표현식을 구성하는데 사용된다.
- JDK 8 버전부터 익명(=무명)함수 (Anonymous Function)를 표현하기 위한 람다 표현식을 지원하기 시작했다.
- 람다식은 아래와 같은 형태를 가지고 있다.

```java
// 람다식 구조
(parameter1, parameter2, ...) -> expression
```

#### 기본 형태

```java
(int x, int y) -> { return x + y; }
```

#### 타입 생략

- 대입 되는 시점에서 매개변수의 타입을 추론할 수 있으므로, 아래와 같이 타입을 생략하여 사용할 수 있다.

```java
(x, y) -> { return x + y; }
```

#### 매개변수가 없을 경우

- 매개변수가 없을 경우 반드시 아래와 같이 빈 괄호() 를 사용해야 한다.

```jsx
() -> { System.out.println("Hello World"); }
```

#### 하나의 매개변수만 있는 경우

- 하나의 매개변수만 있는경우에는 괄호를 생략하여 작성할 수 있다.

```jsx
x -> { System.out.println(x); }
```

#### 한 줄의 실행 코드만 있는 경우

```jsx
() -> System.out.println("Hello World")
```

#### 실행 코드에 반환문만 있는 경우

- 실행 코드에 반환문 하나만 존재하는 경우 중괄호와 return 키워드를 생략할 수 있다.

```jsx
(x, y) -> x + y
```

### 익명 함수

- 람다식은 함수의 이름 없이 사용되기 때문에 익명함수라고 불리기도 한다.
- 사실은 익명 객체이다.

### 람다식

- 자바의 큰 두가지 변화
    - JDK 1.5부터의 Generices (제네릭)
    - JDK 1.8부터의 Lambda expression (람다식)
- 람다는 특정 클래스에 속하지 않고도 사용이 가능했다.
- 람다식의 도입으로 인해 자바는 객체지향 언어임과 동시에 함수형 언어의 기능을 갖출 수 있었다.
- 람다는 메서드를 하나의 식으로 표현한 것

```java
// 일반 메서드
void printValue(String name, int num) {
	System.out.println(name + " = " + num);
}

// 람다식 표현
(name, num) -> System.out.println(name + " = " + num)
```

#### 장점

- 간결하면서도 이해하기 쉽다.
- 함수를 정의하기 위해 클래스를 새로 만들 필요없이 바로 람다식을 통해 메서드 역할 수행이 가능하다.
- 람다식을 사용하여 메서드를 변수처럼 다루는것이 가능하다.
    - 람다식은 다른 메서드의 매개변수로 전달되어지는것이 가능하다.
    - 람다식은 메서드의 결과로 반환되는것이 가능하다.

#### 단점

- 지나치게 남발하면 오히려 코드의 가독성이 떨어지고 지저분해진다.
- 람다를 사용하여 만든 무명함수는 재사용이 불가능하다.
- 디버깅이 어렵다.
- 모든 원소를 전부 순회하는 경우 람다식이 더 느리다.
    - 최종 출력되는 bytecode나 assembly code는 단순 반복문보다 몇 단계를 더 거치게 된다.
- 재귀로 만들기에 부적합하다.

### 람다에서의 타입추론

- 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략이 가능하다.
- 반환타입이 없는 이유 역시 추론이 가능하기 때문이다.

# 8. 3항 연산자

- 조건식? 결과1 : 결과2 형식의 구조로 되어 있다.
- 조건식이 true라면 결과1을 실행, false라면 결과2를 실행한다.

```java
int num = 5>3? 10:20;
// num은 조건식이 참이기 때문에 10이 된다.
```

* 삼항 연산자를 사용하여 코드의 라인이 줄어들었다고 컴파일 속도가 빨라지는 것은 아니다.

* 삼항 연산자를 중복해서 처리할 경우, 가독성이 떨어질 수 있으므로 중복처리는 피하는 것이 좋다.

# 9. 연산자 우선 순위

| 우선 순위 | 연산자 | 내용 |
| --- | --- | --- |
| 1 | (),[] | 괄호 / 대괄호 |
| 2 | !,~,++,-- | 부정/ 증감 연산자 |
| 3 | *, /, % | 곳셈/나눗셈 연산 |
| 4 | +, - | 덧셈/빼기 연산 |
| 5 | <<,>>,>>> | 비트단위 쉬프트 연산자 |
| 6 | <.<=,>,>= | 관계 연산자 |
| 8 | ==, != |  |
| 9 | & | 비트단위의 논리연산 |
| 10 | ^ |  |
| 11 | && | 논리곱 |
| 12 | || | 논리합 |
| 13 | ?: | 조건부 연산자 |
| 14 | =,+=,-=,*=,/=,%=,<<=,>>=,&=,^=,~= | 대입 할당 연산자 |

### 자세한 연산자 표

- JAVA의 더 폭 넓은 우선순위 표이다.

| 순서 | 연산방향 | 연산자 | 피연산자 타입 | 수행 |
| --- | --- | --- | --- | --- |
| 1 | 좌측부터 | . | 객체, 필드(멤버) | 객체 멤버 접근 |
|  |  | [   ] | 배열, int | Array 원소 접근 |
|  |  | ( args ) | 메소드, arglist | 메소드 호출 |
|  |  | ++, -- | 변수 variable ex) ++x | 전위 증감 |
| 2 | 우측부터 | ++, -- | 변수 variable ex) x++ | 후위 증감 |
|  |  | +, - | number 숫자 ex) -3, +3 | 단항 +, 단항 - |
|  |  | ~ | integer | 비트 조건연산자 |
|  |  | ! | boolean | 논리 not연산 |
| 3 | 우측부터 | new | class, arglist | 객체 생성 |
|  |  | ( type ) | type, any | 타입 캐스팅 |
| 4 | 좌측부터 | *,/,% | number (*,/,%)  number | 곱,나누기,나머지 |
| 5 | 좌측부터 | +,- | number (+,-) number | 더하기, 빼기 |
|  |  | + | String + (any) | 스트링에 문자열 더하기 |
| 6 | 좌측부터 | << | integer, integer | left shift |
|  |  | >> | integer, integer | right shift (밀린 비트 부분 1로 메꿈) |
|  |  | >>> | integer, integer | right shift(밀린 비트 0으로 채움) |
| 7 | 좌측부터 | <,<= | number, number | less than, less than equal |
|  |  | >, >= | number, number | greater than, greater than equal |
|  |  | instanceof | reference , type | 타입 비교 |
| 8 | 좌측부터 | == | primitive,primitive | 같은지 비교 |
|  |  | != | primitive,primitive | 안같은지 비교 |
|  |  | == | reference, reference | 같은지 비교 |
|  |  | != | reference, reference | 안같은지 비교 |
| 9 | 좌측부터 | & | integer, integer | 비트 AND |
|  |  | & | boolean,boolean | 논리 AND |
| 10 | 좌측부터 | ^ | integer, integer | 비트 XOR |
|  |  | ^ | boolean,boolean | 논리 XOR |
| 11 | 좌측부터 | | | integer, integer | 비트 OR |
|  |  | | | boolean , boolean | 논리 OR |
| 12 | 좌측부터 | && | boolean, boolean | 조건부 AND |
| 13 | 좌측부터 | || | boolean, boolean | 조건부 OR |
| 14 | 우측부터 | ?: | boolean, any | 조건부 (3항) 연산 |
| 15 | 우측부터 | = | variable, any | 대입 |
|  |  | +=, /=, %=,
+=,-=,<<=,
>>=,>>>=,
&=,^=,|= | variable, any | 대입 + 연산 |
| 16 | 우측부터 | -> | argilist, method body | 람다 |

# 10. • (optional) Java 13. switch 연산자

- Java 12부터 switch 연산자가 추가 되었다.
- 기존의 switch문이 변경된 것이 아니라, switch문의 기능확장이라 생각하면 된다.

### 기존의 switch case 문법

1. 불필요하게 장황하다. (다수의 case, break가 존재)
2. Error 발생시 디버깅이 어렵다.
3. Break 실수를 했을 때 다음 분기로 넘어가게 된다.
4. return 값이 존재할 수 없다.

### 새로운 switch operator

1. break를 사용하지 않아도 된다.
2. yield 존재
3. return 값 존재
4. case -> A 와 같은 형식으로 표현 가능
5. switch의 반환값이 따로 필요하지 않거나 case가 switch에 들어오는 모든 인자를 커버하는 경우 default 항목을 넣어주지 않아도 되나, 이 경우 default -> code를 작성해야 한다.

### Java 12 이전

```jsx
//Java 12 이전
int num = 1;
int returnNum = 0;
switch(num){
    case 1:
        returnNum = 1;
        System.out.println("1들어옴");
        break;
    case 2:
        returnNum = 2;
        System.out.println("2들어옴");
        break;
    case 3:
        returnNum = 3;
        System.out.println("3들어옴");
        break;
}
System.out.println("returnNum : [ " + returnNum + " ]");
```

### Java 12

- ->(화살표) 표현이 가능하고 data만 존재할 경우 return이 가능하다.
- -> 구문을 사용할 경우 break;를 적지 않아도 다음 case 구문으로 넘어가지 않는다.
- -> 표현 오른쪽은 꼭 단일 수행일 필요는 없다. 블록 { } 안에서의 작업도 가능하다.

```jsx
//Java 12
returnNum = switch(num){
    case 1 -> 1;
    case 2 -> 2;
    default -> throw new IllegalStateException("Unexpected value: " + num);
};
System.out.println("returnNum : [ " + returnNum + " ]");
```

### Java 13

- yield 예약어가 추가되었다. (yield x시 x 가 리턴됨.)
- yield는 예약어이지만 변수명으로 사용가능하다. (ex. int yield = 3;)

```jsx
//Java13
returnNum = switch(num){
    case 1 : yield 3;
    default : throw new IllegalStateException("unexpected value : " + num);
};
System.out.println("returnNum : [ " + returnNum + " ]");
```

#### yield 키워드

- 값을 명시적으로 리턴하기 위해 새로운 키워드인 yield를 도입했다.
- 대부분의 경우 case에 대한 처리는 하나의 문장으로 처리하지만 여러 문장으로 작성해야 하는 경우 { }으로 코드 블록을 정의해야 한다.

```jsx
// 스위치 표현식에서 int 값을 리턴하는 예
int j = switch (day) {
    case MONDAY  -> 0;
    case TUESDAY -> 1;
    default      -> {
        int k = day.toString().length();
        int result = f(k);
        yield result;
    }
};
```

- 코드 블럭 내에서 값을 리턴하기 위한 용도가 아닌 경우 컴파일 에러가 발생한다.
- 예를 들어 아래 같은 경우는 에러 발생

```jsx
case MONDAY -> yield 0; // 컴파일 에러. 스위치 표현식에서는 코드 블록내에서만 사용 가능하다.
```

- 단, 아래 같이 기존 스위치 문장에서는 사용할 수 있다. (코드 블록 여부와는 상관 없이 사용)

```jsx
// 스위치 문장에서 값 리턴 예
int result = switch (s) {
    case "Foo": 
        yield 1;
    case "Bar":
        yield 2;
    default:
        System.out.println("Neither Foo nor Bar, hmmm...");
        yield 0;
};
```

- 이유는 “case 문장 : “ 자체가 여러 라인의 코드를 작성할 수 있는 블록으로 인식하기 때문이다.
- yield 키워드를 사용 할 경우 break 문장이 없어서 스위치 문장이 종료됨으로 기존과 다르게 동작한다.


> #### 참고
> [1] (https://tecoble.techcourse.co.kr/post/2020-07-31-solid-1/)</br>
> [2] (https://tecoble.techcourse.co.kr/post/2021-04-26-instanceof/)</br>
> [3] (https://hudi.blog/lambda-and-functional-interface/)</br>
> [4] (https://velog.io/@hp5234/JAVA-3%ED%8E%B8-%ED%99%94%EC%82%B4%ED%91%9C%EC%97%B0%EC%82%B0%EC%9E%90-%EB%9E%8C%EB%8B%A4-%EA%B8%B0%EC%B4%88)</br>
> [5] (https://github.com/NewSainTurtle/CS-study/edit/main/Java/%EA%B9%80%EA%B0%95%ED%98%B8/03_%EC%97%B0%EC%82%B0%EC%9E%90.md)</br>
> [6] (https://mostadmired.tistory.com/127)</br>
> [7] (https://castleone.tistory.com/6)</br>
